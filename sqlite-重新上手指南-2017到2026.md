# SQLite 重新上手指南（2017 → 2026）

> 写给 8 年没深度用 SQLite 的自己。你 2017 年掌握的核心概念（代理键、范式、触发器、
> FTS、JOIN、INSERT OR IGNORE 两步走）都还有效，但 SQLite 从 3.17 演进到了 3.52，
> 加了大量"终于有了"的特性。这份指南按优先级排列。
>
> 第零章是完整的 SQL 入门教程（CRUD、WHERE、NULL、CASE、聚合、JOIN、子查询、
> UNION、字符串函数），既给完全不懂 SQL 的人从零学习，也可以当速查手册翻阅。
> 有基础的话直接从第一章开始。

---

## 零、SQL 与 SQLite 入门

如果你是第一次接触 SQL，从头读起。如果有基础但生疏了，当速查手册翻阅。

### 0.1 SQLite 不需要"创建数据库"

和 MySQL、PostgreSQL 不同，SQLite 没有 `CREATE DATABASE` 命令。SQLite 的数据库就是一个文件——打开它就是创建它：

```bash
# 这条命令做了两件事：如果 myapp.db 不存在就创建它，然后打开它
sqlite3 myapp.db

# 就这样，你已经有一个数据库了
# 退出用 .quit
```

在代码里也一样：

```python
import sqlite3
conn = sqlite3.connect('myapp.db')   # 文件不存在就自动创建
conn = sqlite3.connect(':memory:')   # 内存数据库，关闭即消失
```

所以标准 SQL 的命令在 SQLite 中的对应关系：

| 标准 SQL 命令 | SQLite 中 | 说明 |
|-------------|----------|------|
| `CREATE DATABASE` | ❌ 不需要 | 打开文件即创建 |
| `ALTER DATABASE` | ❌ 不需要 | 用 PRAGMA 配置 |
| `CREATE TABLE` | ✅ | 完全支持 |
| `ALTER TABLE` | ✅ | 支持 ADD/DROP/RENAME COLUMN |
| `DROP TABLE` | ✅ | 完全支持 |
| `CREATE INDEX` | ✅ | 完全支持 |
| `DROP INDEX` | ✅ | 完全支持 |
| `INSERT INTO` | ✅ | 完全支持 |
| `SELECT` | ✅ | 完全支持 |
| `UPDATE` | ✅ | 完全支持 |
| `DELETE` | ✅ | 完全支持（没有 TRUNCATE，用 `DELETE FROM` 代替） |

### 0.2 创建表与数据类型

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY,    -- 主键，自动递增
    name TEXT NOT NULL,        -- 不允许为空
    email TEXT UNIQUE,         -- 唯一约束
    age INTEGER,
    balance REAL,              -- 浮点数
    avatar BLOB,              -- 二进制数据
    created_at TEXT DEFAULT (datetime('now'))  -- 默认值
);
```

SQLite 只有 5 种存储类型：`INTEGER`、`REAL`、`TEXT`、`BLOB`、`NULL`。比 MySQL 的几十种类型简单得多。

```sql
-- 修改表
ALTER TABLE users ADD COLUMN phone TEXT;          -- 加列
ALTER TABLE users DROP COLUMN phone;              -- 删列（3.35+）
ALTER TABLE users RENAME COLUMN name TO full_name; -- 改列名（3.25+）

-- 删除表
DROP TABLE users;
DROP TABLE IF EXISTS users;  -- 表不存在也不报错
```

### 0.3 增删改查（CRUD）

**插入（Create）：**

```sql
INSERT INTO users (name, email, age) VALUES ('Alice', 'alice@example.com', 30);

-- 批量插入
INSERT INTO users (name, email, age) VALUES
    ('Bob', 'bob@example.com', 25),
    ('Carol', 'carol@example.com', 35);
```

**查询（Read）：**

```sql
SELECT * FROM users;                          -- 所有列所有行
SELECT name, email FROM users;                -- 指定列
SELECT * FROM users WHERE age > 25;           -- 条件筛选
SELECT * FROM users ORDER BY age DESC;        -- 排序（DESC 降序，ASC 升序）
SELECT * FROM users LIMIT 10;                 -- 只取前 10 行
SELECT * FROM users LIMIT 10 OFFSET 20;      -- 跳过 20 行取 10 行
SELECT DISTINCT city FROM users;              -- 去重
```

**更新（Update）：**

```sql
UPDATE users SET age = 31 WHERE name = 'Alice';
UPDATE users SET age = age + 1;  -- ⚠️ 没有 WHERE 就更新全表！
```

**删除（Delete）：**

```sql
DELETE FROM users WHERE name = 'Bob';
DELETE FROM users;  -- ⚠️ 删除所有行！
```

### 0.4 WHERE 条件大全

```sql
-- 比较
WHERE age = 30
WHERE age != 30             -- 或 age <> 30
WHERE age > 25
WHERE age >= 25
WHERE age BETWEEN 25 AND 35   -- 包含两端

-- 逻辑组合
WHERE age > 25 AND city = 'Beijing'
WHERE age > 25 OR city = 'Beijing'
WHERE NOT (age > 25)

-- 列表匹配
WHERE city IN ('Beijing', 'Shanghai', 'Shenzhen')
WHERE city NOT IN ('Beijing', 'Shanghai')

-- 模糊匹配
WHERE name LIKE 'A%'        -- A 开头（% 匹配任意多字符）
WHERE name LIKE '%son'      -- son 结尾
WHERE name LIKE '_o%'       -- 第二个字符是 o（_ 匹配单个字符）
WHERE name GLOB 'A*'        -- GLOB 区分大小写，LIKE 不区分

-- NULL 判断（⚠️ 不能用 = NULL，必须用 IS）
WHERE email IS NULL
WHERE email IS NOT NULL
```

### 0.5 算术运算与表达式

```sql
-- 基本算术（可以直接在 SELECT 中计算）
SELECT name, price, quantity, price * quantity AS total FROM order_items;
SELECT name, salary, salary * 12 AS annual_salary FROM employees;
SELECT name, score, score / 100.0 AS percentage FROM students;  -- 注意用 100.0 而非 100，避免整数除法

-- 取余
SELECT 17 % 5;       -- 2
SELECT mod(17, 5);    -- 2.0（3.35+ 数学函数版本）

-- 四舍五入
SELECT round(3.14159, 2);   -- 3.14
SELECT round(price * 1.08, 2) AS price_with_tax FROM products;

-- 类型转换
SELECT CAST('123' AS INTEGER);   -- 123
SELECT CAST(3.14 AS INTEGER);    -- 3
SELECT typeof(42), typeof('hello'), typeof(3.14), typeof(NULL);
-- 'integer', 'text', 'real', 'null'
```

### 0.6 NULL 处理

NULL 是 SQL 中最容易踩坑的概念。NULL 不是 0，不是空字符串，它表示"未知"。

```sql
-- ⚠️ NULL 的三值逻辑陷阱
SELECT NULL = NULL;      -- NULL（不是 true！）
SELECT NULL != NULL;     -- NULL（不是 true！）
SELECT NULL > 0;         -- NULL
SELECT NULL + 10;        -- NULL（任何值和 NULL 运算都是 NULL）

-- 正确判断 NULL
SELECT * FROM users WHERE email IS NULL;
SELECT * FROM users WHERE email IS NOT NULL;

-- COALESCE：返回参数列表中第一个不为 NULL 的值（最常用）
SELECT name, COALESCE(nickname, name) AS display_name FROM users;
SELECT COALESCE(phone, email, '无联系方式') AS contact FROM users;

-- IFNULL：COALESCE 的两参数简化版（SQLite 特有）
SELECT name, IFNULL(phone, '未填写') AS phone FROM users;

-- NULLIF：两个值相等时返回 NULL（用于把特殊值转为 NULL）
SELECT NULLIF(score, 0) AS score FROM students;  -- 0 分变成 NULL
SELECT total / NULLIF(count, 0) AS avg FROM stats;  -- 避免除以零！

-- 聚合函数自动忽略 NULL
SELECT AVG(score) FROM students;      -- NULL 的行不参与计算
SELECT COUNT(email) FROM users;       -- 只计非 NULL 行
SELECT COUNT(*) FROM users;           -- 计所有行（包括 NULL）
```

**NULL 排序行为：**

```sql
-- SQLite 中 NULL 在 ASC 排序时排最前面，DESC 时排最后面
SELECT * FROM users ORDER BY age;       -- NULL, 20, 25, 30
SELECT * FROM users ORDER BY age DESC;  -- 30, 25, 20, NULL

-- 3.30+ 可以用 NULLS FIRST / NULLS LAST 控制
SELECT * FROM users ORDER BY age NULLS LAST;   -- 20, 25, 30, NULL
```

### 0.7 CASE 条件表达式

CASE 是 SQL 的 if-else，可以在 SELECT、WHERE、ORDER BY 中使用。

```sql
-- 基本语法
SELECT name, score,
    CASE
        WHEN score >= 90 THEN '优秀'
        WHEN score >= 80 THEN '良好'
        WHEN score >= 60 THEN '及格'
        ELSE '不及格'
    END AS grade
FROM students;

-- 简写形式（匹配单个值）
SELECT name,
    CASE status
        WHEN 'active' THEN '活跃'
        WHEN 'inactive' THEN '停用'
        WHEN 'banned' THEN '封禁'
        ELSE '未知'
    END AS status_cn
FROM users;

-- 在 ORDER BY 中使用（自定义排序顺序）
SELECT * FROM tasks ORDER BY
    CASE priority
        WHEN 'urgent' THEN 1
        WHEN 'high' THEN 2
        WHEN 'medium' THEN 3
        WHEN 'low' THEN 4
    END;

-- IIF 函数（3.32+）：简化二选一的 CASE
SELECT name, iif(score >= 60, '通过', '未通过') AS result FROM students;
-- 等价于 CASE WHEN score >= 60 THEN '通过' ELSE '未通过' END

-- CASE + 聚合 = 行转列（Pivot，非常实用）
SELECT
    department,
    COUNT(CASE WHEN status = 'active' THEN 1 END) AS active_count,
    COUNT(CASE WHEN status = 'inactive' THEN 1 END) AS inactive_count,
    SUM(CASE WHEN gender = 'M' THEN salary ELSE 0 END) AS male_salary_total,
    SUM(CASE WHEN gender = 'F' THEN salary ELSE 0 END) AS female_salary_total
FROM employees
GROUP BY department;
```

> Pivot（行转列）是报表中非常常见的需求，SQLite 没有专门的 PIVOT 语法，
> 但用 `CASE + 聚合函数 + GROUP BY` 可以实现任何 Pivot。

### 0.8 聚合与分组

```sql
-- 聚合函数
SELECT COUNT(*) FROM users;                    -- 总行数
SELECT COUNT(email) FROM users;                -- email 不为 NULL 的行数
SELECT AVG(age) FROM users;                    -- 平均值
SELECT SUM(amount) FROM orders;                -- 求和
SELECT MIN(age), MAX(age) FROM users;          -- 最小值、最大值

-- GROUP BY：按组聚合
SELECT city, COUNT(*) AS user_count
FROM users
GROUP BY city;

-- HAVING：对分组结果筛选（WHERE 筛选行，HAVING 筛选组）
SELECT city, COUNT(*) AS user_count
FROM users
GROUP BY city
HAVING user_count > 10;
```

**SQL 执行顺序**——理解了这个就理解了为什么 WHERE 不能用聚合函数而 HAVING 可以：

```
FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT
先确定数据来源 → 筛选行 → 分组 → 筛选组 → 选列/计算 → 排序 → 截取
```

### 0.9 JOIN — 连表查询

单表查询是起点，但现实中的数据几乎都分布在多张表里。JOIN 是 SQL 最核心的能力。

假设有两张表：

```sql
CREATE TABLE customers (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL
);
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(id),
    amount REAL,
    order_date TEXT
);

-- 示例数据
-- customers: (1, 'Alice'), (2, 'Bob'), (3, 'Carol')
-- orders:    (101, 1, 100.0, '2026-01-15')   ← Alice 的订单
--            (102, 1, 200.0, '2026-02-01')   ← Alice 的订单
--            (103, 2,  50.0, '2026-01-20')   ← Bob 的订单
--            (104, 9,  75.0, '2026-02-10')   ← customer_id=9 不存在！
```

**INNER JOIN — 只取两边都匹配的行**

```sql
SELECT c.name, o.amount, o.order_date
FROM customers c
INNER JOIN orders o ON c.id = o.customer_id;

-- 结果（Carol 没订单所以不出现，104 号订单 customer_id=9 也不出现）：
-- Alice | 100.0 | 2026-01-15
-- Alice | 200.0 | 2026-02-01
-- Bob   |  50.0 | 2026-01-20
```

可以画个图理解：

```
customers        orders               INNER JOIN 结果
┌──┬───────┐    ┌───┬────┬───────┐    ┌───────┬───────┐
│1 │ Alice │────│101│ 1  │ 100.0 │    │ Alice │ 100.0 │
│  │       │────│102│ 1  │ 200.0 │    │ Alice │ 200.0 │
│2 │ Bob   │────│103│ 2  │  50.0 │    │ Bob   │  50.0 │
│3 │ Carol │    │104│ 9  │  75.0 │    └───────┴───────┘
└──┴───────┘    └───┴────┴───────┘    Carol 没匹配 → 不出现
                 104 没匹配 → 不出现
```

**LEFT JOIN — 保留左表全部，右表没匹配的填 NULL**

```sql
SELECT c.name, o.amount
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id;

-- 结果（Carol 也出现了，但 amount 为 NULL）：
-- Alice | 100.0
-- Alice | 200.0
-- Bob   |  50.0
-- Carol | NULL     ← LEFT JOIN 的效果
```

```
LEFT JOIN 结果
┌───────┬───────┐
│ Alice │ 100.0 │
│ Alice │ 200.0 │
│ Bob   │  50.0 │
│ Carol │ NULL  │  ← 左表的行一定会出现
└───────┴───────┘
```

**LEFT JOIN 找"没有"的记录——非常实用的模式：**

```sql
-- 找出从未下过单的客户
SELECT c.name
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
WHERE o.id IS NULL;
-- 结果：Carol
```

**多表 JOIN（链式关联）：**

```sql
SELECT c.name, p.product_name, oi.quantity
FROM customers c
JOIN orders o ON c.id = o.customer_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE o.order_date > '2026-01-01';
```

**自连接 — 表跟自己 JOIN（处理层级关系）：**

```sql
-- 员工表里 manager_id 指向同一张表的 id
SELECT e.name AS employee, m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;
```

**JOIN 类型总结：**

```
INNER JOIN      取交集（两边都匹配的行）       ← 最常用
LEFT JOIN       左表全部 + 右表匹配的          ← 最常用
RIGHT JOIN      右表全部 + 左表匹配的          SQLite 3.39+ 才支持
FULL OUTER JOIN 两边全部                       SQLite 3.39+ 才支持
CROSS JOIN      笛卡尔积（慎用，结果行数爆炸）
```

> INNER JOIN 和 LEFT JOIN 覆盖日常 95% 的场景。

### 0.10 别名

```sql
-- 表别名（JOIN 时几乎必用，避免写冗长的表名）
SELECT c.name, o.amount
FROM customers c              -- c 是 customers 的别名
JOIN orders o ON c.id = o.customer_id;   -- o 是 orders 的别名

-- 列别名
SELECT name, amount * 1.1 AS amount_with_tax FROM orders;
SELECT COUNT(*) AS total FROM users;
```

### 0.11 子查询（Subquery）

子查询是嵌套在另一个查询里面的 SELECT。可以出现在三个位置：

**WHERE 中 — 最常用：**

```sql
-- 找出消费高于平均值的用户
SELECT name, total_spent
FROM users
WHERE total_spent > (SELECT AVG(total_spent) FROM users);

-- IN + 子查询
SELECT name FROM customers
WHERE id IN (SELECT customer_id FROM orders WHERE amount > 1000);

-- EXISTS：只关心"存不存在"，通常比 IN 高效
SELECT name FROM customers c
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);
```

**FROM 中 — 派生表：**

```sql
-- 先聚合再筛选（当你不能在 WHERE 中用聚合函数时）
SELECT department, avg_salary
FROM (
    SELECT department, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department
) sub
WHERE avg_salary > 10000;
```

**SELECT 中 — 标量子查询（返回单个值）：**

```sql
SELECT name,
       (SELECT COUNT(*) FROM orders WHERE orders.user_id = users.id) AS order_count
FROM users;
```

> 子查询和 CTE（WITH 语句）可以互相替代。CTE 可读性更好，子查询更紧凑。
> 后面第二章的 CTE 章节会详细讲 WITH 语法。

### 0.12 UNION — 合并结果集

UNION 把两个 SELECT 的结果上下拼接在一起（列数和类型必须对应）。

```sql
-- UNION：合并并去重
SELECT name, email FROM employees
UNION
SELECT name, email FROM contractors;

-- UNION ALL：合并但保留重复（更快，不需要去重排序）
SELECT name, 'employee' AS source FROM employees
UNION ALL
SELECT name, 'contractor' AS source FROM contractors;
```

**UNION vs UNION ALL：**

```
employees          contractors         UNION ALL 结果
┌───────┐         ┌───────┐          ┌───────┬────────────┐
│ Alice │         │ Carol │          │ Alice │ employee   │
│ Bob   │         │ Alice │          │ Bob   │ employee   │
└───────┘         └───────┘          │ Carol │ contractor │
                                     │ Alice │ contractor │  ← Alice 出现两次
                                     └───────┴────────────┘

                                     UNION 结果（去重后）
                                     ┌───────┐
                                     │ Alice │  ← 只出现一次
                                     │ Bob   │
                                     │ Carol │
                                     └───────┘
```

**实际用途：**

```sql
-- 合并不同时期的数据
SELECT '2025' AS year, * FROM sales_2025
UNION ALL
SELECT '2026' AS year, * FROM sales_2026;

-- 生成固定数据（不需要建表）
SELECT 1 AS month, '一月' AS name
UNION ALL SELECT 2, '二月'
UNION ALL SELECT 3, '三月';

-- EXCEPT：取差集（在 A 中但不在 B 中）
SELECT email FROM all_users
EXCEPT
SELECT email FROM unsubscribed;

-- INTERSECT：取交集（同时在 A 和 B 中）
SELECT email FROM list_a
INTERSECT
SELECT email FROM list_b;
```

### 0.13 字符串函数

```sql
-- 长度
SELECT length('hello');          -- 5
SELECT length('你好');            -- 2（按字符计，不是字节）

-- 大小写转换
SELECT upper('hello');           -- HELLO
SELECT lower('HELLO');           -- hello

-- 截取
SELECT substr('hello world', 1, 5);  -- hello（从位置1开始，取5个字符）
SELECT substr('hello world', 7);     -- world（从位置7到末尾）

-- 查找位置
SELECT instr('hello world', 'world');  -- 7（找到的起始位置，找不到返回 0）

-- 替换
SELECT replace('hello world', 'world', 'SQLite');  -- hello SQLite

-- 去除空白
SELECT trim('  hello  ');         -- 'hello'
SELECT ltrim('  hello  ');        -- 'hello  '
SELECT rtrim('  hello  ');        -- '  hello'
SELECT trim('xxhelloxx', 'x');   -- 'hello'（可指定要去除的字符）

-- 拼接
SELECT 'Hello' || ' ' || 'World';           -- Hello World
SELECT concat('Hello', ' ', 'World');        -- Hello World（3.44+）
SELECT concat_ws(', ', 'Alice', 'Bob');      -- Alice, Bob（3.44+）

-- 补齐（用于格式化输出）
SELECT printf('%05d', 42);        -- 00042
SELECT printf('%.2f', 3.14159);   -- 3.14

-- 聚合拼接
SELECT group_concat(name, ', ') FROM users;  -- Alice, Bob, Carol
SELECT group_concat(name, ', ') FROM users GROUP BY department;
```

**字符串函数在实际中的用途：**

```sql
-- 从 email 提取域名
SELECT substr(email, instr(email, '@') + 1) AS domain FROM users;

-- 姓名脱敏
SELECT substr(name, 1, 1) || '**' AS masked_name FROM users;

-- 清洗数据
UPDATE users SET phone = replace(replace(phone, '-', ''), ' ', '');
```

### 0.14 索引入门

索引就是给列建一个"目录"，让查询不用逐行扫描：

```sql
-- 创建索引
CREATE INDEX idx_users_email ON users(email);

-- 唯一索引（同时保证值不重复）
CREATE UNIQUE INDEX idx_users_email ON users(email);

-- 删除索引
DROP INDEX idx_users_email;
```

什么时候加索引？简单规则：经常出现在 `WHERE`、`JOIN ON`、`ORDER BY` 后面的列，考虑加索引。

### 0.15 SQLite 特有的注意事项

```sql
-- 1. 外键默认关闭！必须手动打开
PRAGMA foreign_keys = ON;

-- 2. 没有 CREATE DATABASE / TRUNCATE TABLE / 布尔类型
--    数据库 = 文件，删全表用 DELETE FROM，布尔用 0/1

-- 3. 类型是"建议"而非强制
CREATE TABLE t (age INTEGER);
INSERT INTO t VALUES ('hello');  -- 不报错！INTEGER 列存了文本
-- 用 STRICT 表避免这个问题（3.37+）：
CREATE TABLE t (age INTEGER) STRICT;
```

---

## 一、你已经知道但可能生疏的（快速复习）

这些是你 2017 笔记里涉及的内容，概念没变，快速过一遍找回手感。

### 1.1 代理键 vs 自然键

你当时的结论完全正确，现在依然适用：

- 有外键关联多的表 → 用 `INTEGER PRIMARY KEY`（自动成为 rowid 的别名）
- 多对多中间表 → 组合键做主键，不需要自增键
- **依然不要用 AUTOINCREMENT**，除非你真的需要保证 id 永不回收（绝大多数情况不需要）

```sql
-- 2017 和 2026 一样，这就够了
CREATE TABLE contacts (
    id INTEGER PRIMARY KEY,  -- 自动成为 rowid 别名，自增但非 AUTOINCREMENT
    name TEXT NOT NULL,
    phone TEXT
);
```

### 1.2 范式与表设计（1NF / 2NF / 3NF 详解）

你笔记里那句经典口诀永远不过时：

> **"The data depends on the key [1NF], the whole key [2NF] and nothing but the key [3NF]."**

但具体什么意思？用例子说清楚。

**第一范式（1NF）：每个格子只放一个值**

违反 1NF 的典型反模式——逗号分隔串：

```
❌ 订单表（违反 1NF）
┌──────────┬──────────────────────┬───────┐
│ order_id │ products             │ total │
├──────────┼──────────────────────┼───────┤
│ 1001     │ 手机,耳机,充电器        │ 3500  │
│ 1002     │ 笔记本,鼠标            │ 6200  │
└──────────┴──────────────────────┴───────┘
```

问题：怎么查"包含耳机的订单"？只能 `LIKE '%耳机%'`，慢、不准确、无法加索引。

```
✅ 拆成两张表（满足 1NF）

orders 表                    order_items 表
┌──────────┬───────┐         ┌──────────┬──────────┬───────┐
│ order_id │ total │         │ order_id │ product  │ price │
├──────────┼───────┤         ├──────────┼──────────┼───────┤
│ 1001     │ 3500  │         │ 1001     │ 手机     │ 2999  │
│ 1002     │ 6200  │         │ 1001     │ 耳机     │  299  │
└──────────┴───────┘         │ 1001     │ 充电器   │  202  │
                             │ 1002     │ 笔记本   │ 5999  │
                             │ 1002     │ 鼠标     │  201  │
                             └──────────┴──────────┴───────┘
```

现在查询很简单：`SELECT * FROM order_items WHERE product = '耳机'`。

**第二范式（2NF）：非主属性必须依赖完整的主键（不能只依赖主键的一部分）**

这个问题只在组合主键时出现。

```
❌ 违反 2NF（选课表，主键是 学生id + 课程id）
┌───────────┬───────────┬──────────────┬──────────┬─────────┐
│ student_id│ course_id │ student_name │ course   │ grade   │
├───────────┼───────────┼──────────────┼──────────┼─────────┤
│ S001      │ C001      │ 张三         │ 数据库    │ 85      │
│ S001      │ C002      │ 张三         │ 操作系统  │ 90      │  ← 张三出现了两次
│ S002      │ C001      │ 李四         │ 数据库    │ 78      │  ← 数据库出现了两次
└───────────┴───────────┴──────────────┴──────────┴─────────┘

问题：
- student_name 只依赖 student_id（主键的一部分），不依赖 course_id
- course 只依赖 course_id（主键的一部分），不依赖 student_id
- 张三改名要改多行，漏改就数据不一致
```

```
✅ 拆表（满足 2NF）

students 表              courses 表              enrollments 表
┌─────┬──────┐          ┌─────┬────────┐        ┌─────────┬─────────┬───────┐
│ id  │ name │          │ id  │ name   │        │ student │ course  │ grade │
├─────┼──────┤          ├─────┼────────┤        ├─────────┼─────────┼───────┤
│ S001│ 张三 │          │ C001│ 数据库  │        │ S001    │ C001    │ 85    │
│ S002│ 李四 │          │ C002│ 操作系统│        │ S001    │ C002    │ 90    │
└─────┴──────┘          └─────┴────────┘        │ S002    │ C001    │ 78    │
                                                └─────────┴─────────┴───────┘
张三改名只需改一个地方
```

**第三范式（3NF）：非主属性不能依赖其他非主属性（只能依赖主键）**

```
❌ 违反 3NF
┌──────────┬──────────┬─────────────┬────────────────┐
│ order_id │ customer │ customer_city│ city_province   │
├──────────┼──────────┼─────────────┼────────────────┤
│ 1001     │ 张三     │ 深圳         │ 广东            │
│ 1002     │ 李四     │ 杭州         │ 浙江            │
│ 1003     │ 王五     │ 深圳         │ 广东            │  ← "深圳→广东" 重复了
└──────────┴──────────┴─────────────┴────────────────┘

问题：city_province 依赖 customer_city，而 customer_city 不是主键
      → city_province 传递依赖于主键 order_id，违反 3NF
      → 深圳对应广东这个信息存了多份
```

```
✅ 拆出城市表（满足 3NF）

orders 表                    cities 表
┌──────────┬──────────┬──────┐  ┌──────┬──────────┐
│ order_id │ customer │ city │  │ city │ province │
├──────────┼──────────┼──────┤  ├──────┼──────────┤
│ 1001     │ 张三     │ 深圳 │  │ 深圳 │ 广东     │
│ 1002     │ 李四     │ 杭州 │  │ 杭州 │ 浙江     │
│ 1003     │ 王五     │ 深圳 │  └──────┴──────────┘
└──────────┴──────────┴──────┘
```

**实际原则：**

- 大多数业务系统做到 3NF 就足够了
- 读侧（报表、汇总）可以故意反规范化来换取查询速度（见第十章 CQRS）
- 规范化消除冗余 → 写入安全；反规范化增加冗余 → 读取快速。这是永恒的权衡

### 1.3 外键

**依然默认关闭！** 每次连接都要手动开：

```sql
PRAGMA foreign_keys = ON;
```

你 2017 笔记里提到 FMDB 用 `executeQuery` 而非 `executeUpdate` 来开外键，这个坑对其他 ORM/驱动也一样——PRAGMA 不是 DML。

### 1.4 触发器

语法没变。你当时记录的要点依然有效：
- INSERT → `NEW`，DELETE → `OLD`，UPDATE → `NEW` + `OLD`
- `RAISE()` 必须在 `SELECT` 里
- `REPLACE` 默认不触发 DELETE trigger，需要 `PRAGMA recursive_triggers = ON`

### 1.5 group_concat

你当时强调"不要自己拼接字符串"。现在更好了——3.44 新增了 `concat()` 和 `concat_ws()`：

```sql
-- 旧（你熟悉的）
SELECT group_concat(name, ', ') FROM users;

-- 新（3.44+），不需要 GROUP BY 也能拼接
SELECT concat_ws(', ', first_name, last_name) FROM users;
```

### 1.6 EXPLAIN QUERY PLAN

用法没变，但输出格式更清晰了。你当时记录的 SCAN（全表）vs 使用索引的判断标准完全适用。

---

## 二、2017 年之后的重大新特性（按重要性排列）

这是重点部分。SQLite 在 2018–2025 年加了大量实用特性。

### 2.1 ⭐ UPSERT — ON CONFLICT（3.24，2018）

**你 2017 笔记里那个 "INSERT OR IGNORE + SELECT" 两步走的问题，现在一步解决了。**

```sql
-- 2017 年的做法（你笔记第3点）
INSERT OR IGNORE INTO foo(data) VALUES('Some text');
SELECT id FROM foo WHERE data = 'Some text';

-- 2026 年直接用 UPSERT
INSERT INTO foo(data) VALUES('Some text')
ON CONFLICT(data) DO UPDATE SET data = excluded.data
RETURNING id;  -- 还能直接返回 id（见 2.5 RETURNING）
```

完整的 UPSERT 语法：

```sql
-- 词频统计的经典例子
CREATE TABLE vocabulary(word TEXT PRIMARY KEY, count INT DEFAULT 1);

INSERT INTO vocabulary(word) VALUES('jovial')
ON CONFLICT(word) DO UPDATE SET count = count + 1;

-- 通讯录：仅当新数据更新时才覆盖
INSERT INTO phonebook(name, phone, updated_at)
VALUES('Alice', '1234', '2026-02-11')
ON CONFLICT(name) DO UPDATE SET
    phone = excluded.phone,
    updated_at = excluded.updated_at
WHERE excluded.updated_at > phonebook.updated_at;
```

关键词 `excluded` 引用的是"本来要插入的值"。这比 `INSERT OR REPLACE` 好得多——REPLACE 会删除再插入（触发 DELETE trigger、重置 rowid），UPSERT 是真正的原地更新。

### 2.2 ⭐ 窗口函数（3.25，2018）

这是 SQL 进阶最重要的能力，你 2017 年时 SQLite 还没有。

核心概念：在不折叠行的情况下做聚合计算。

```sql
-- 每个部门薪资排名
SELECT name, department, salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_rank
FROM employees;

-- 环比增长
SELECT month, revenue,
    revenue - LAG(revenue) OVER (ORDER BY month) AS growth
FROM monthly_stats;

-- 累计求和
SELECT date, amount,
    SUM(amount) OVER (ORDER BY date) AS running_total
FROM transactions;

-- 移动平均（3日）
SELECT date, value,
    AVG(value) OVER (
        ORDER BY date
        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
    ) AS moving_avg_3
FROM measurements;
```

**排名函数家族：**

| 函数 | 行为 | 示例结果 |
|------|------|---------|
| `ROW_NUMBER()` | 永不重复 | 1, 2, 3, 4 |
| `RANK()` | 并列跳号 | 1, 2, 2, 4 |
| `DENSE_RANK()` | 并列不跳号 | 1, 2, 2, 3 |

**偏移函数：**

| 函数 | 作用 |
|------|------|
| `LAG(col, n)` | 前 n 行的值 |
| `LEAD(col, n)` | 后 n 行的值 |
| `FIRST_VALUE(col)` | 窗口第一行 |
| `LAST_VALUE(col)` | 窗口最后一行（注意需要显式指定窗口范围） |
| `NTH_VALUE(col, n)` | 窗口第 n 行 |

**经典应用——取每组 Top N：**

```sql
WITH ranked AS (
    SELECT *, ROW_NUMBER() OVER (PARTITION BY category ORDER BY score DESC) AS rn
    FROM items
)
SELECT * FROM ranked WHERE rn <= 3;
```

**窗口范围（Frame）：**

```
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW   -- 从头到当前（默认）
ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING            -- 前后各2行
ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING    -- 当前到末尾
```

**FILTER 子句（配合窗口函数使用）：**

```sql
-- 只统计状态为 'paid' 的累计金额
SELECT date,
    SUM(amount) FILTER (WHERE status = 'paid') OVER (ORDER BY date) AS paid_running
FROM orders;
```

> 注意：FILTER 目前只能用在带 OVER 的窗口函数上，不能用在普通 GROUP BY 聚合上。

### 2.3 ⭐ CTE 与递归 CTE（你 2017 年 SQLite 已支持但可能没深入用过）

CTE 本身 SQLite 3.8 就有了，但现在用起来更方便——3.35 加了 MATERIALIZED 提示。

```sql
-- 基本 CTE：让复杂查询可读
WITH active_users AS (
    SELECT * FROM users WHERE status = 'active'
),
user_orders AS (
    SELECT user_id, COUNT(*) AS cnt, SUM(amount) AS total
    FROM orders
    GROUP BY user_id
)
SELECT u.name, o.cnt, o.total
FROM active_users u
LEFT JOIN user_orders o ON u.id = o.user_id;

-- MATERIALIZED CTE（3.35+）：同一 CTE 用多次时避免重复计算
WITH history AS MATERIALIZED (
    SELECT * FROM audit_log WHERE date > '2025-01-01'
)
SELECT * FROM history WHERE action = 'create'
EXCEPT
SELECT * FROM history WHERE action = 'delete';
```

**递归 CTE——处理树形结构：**

你 2017 年做通讯录/聊天组时大概率遇到过层级数据，当时只能在代码里递归查询。现在 SQL 里就能搞定：

```sql
-- 组织架构：从某个人开始，找出所有下属
WITH RECURSIVE subordinates AS (
    -- 起点
    SELECT id, name, manager_id, 0 AS depth
    FROM employees WHERE id = 1

    UNION ALL

    -- 递归
    SELECT e.id, e.name, e.manager_id, s.depth + 1
    FROM employees e
    INNER JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates ORDER BY depth, name;
```

### 2.4 ⭐ STRICT 表（3.37，2021）

**这可能是你最想要的特性。** SQLite 的动态类型一直是隐患（你可以往 INTEGER 列插 'hello'），STRICT 表终于解决了：

```sql
CREATE TABLE measurements (
    id INTEGER PRIMARY KEY,
    sensor_name TEXT NOT NULL,
    value REAL NOT NULL,
    recorded_at TEXT NOT NULL
) STRICT;

-- 现在这会报错！
INSERT INTO measurements VALUES (1, 'temp', 'not_a_number', '2026-02-11');
-- Runtime error: type mismatch on measurements.value
```

STRICT 表允许的类型：`INT`、`INTEGER`、`REAL`、`TEXT`、`BLOB`、`ANY`。

> 建议：新建的表如果不需要动态类型的灵活性，都加 `STRICT`。

### 2.5 RETURNING 子句（3.35，2021）

INSERT/UPDATE/DELETE 现在都可以直接返回被影响的行：

```sql
-- 插入并获取自增 id（不再需要 last_insert_rowid()）
INSERT INTO users(name, email) VALUES('Alice', 'alice@example.com')
RETURNING id;

-- 更新并返回旧值和新值
UPDATE accounts SET balance = balance - 100
WHERE id = 1
RETURNING id, balance;

-- 删除并返回被删的行
DELETE FROM sessions WHERE expires_at < datetime('now')
RETURNING user_id, session_token;

-- 和 UPSERT 配合
INSERT INTO kv(key, value) VALUES('theme', 'dark')
ON CONFLICT(key) DO UPDATE SET value = excluded.value
RETURNING *;
```

### 2.6 RIGHT JOIN 和 FULL OUTER JOIN（3.39，2022）

你 2017 年笔记明确写了 "sqlite 只支持 left outer join"。现在支持了：

```sql
-- RIGHT JOIN
SELECT o.*, c.name
FROM orders o RIGHT JOIN customers c ON o.customer_id = c.id;

-- FULL OUTER JOIN
SELECT *
FROM table_a a FULL OUTER JOIN table_b b ON a.key = b.key;
```

不过实际使用中 LEFT JOIN 仍然最常用，RIGHT JOIN 和 FULL OUTER JOIN 是锦上添花。

### 2.7 JSON 内置支持（3.38，2022；JSONB 3.45，2024）

SQLite 现在内置 JSON 函数，不需要额外加载扩展：

```sql
-- 存储 JSON
CREATE TABLE events (
    id INTEGER PRIMARY KEY,
    data TEXT  -- 存 JSON 字符串
) STRICT;

INSERT INTO events(data) VALUES ('{"type":"click","x":100,"y":200,"tags":["ui","button"]}');

-- 提取字段（两种语法）
SELECT json_extract(data, '$.type') FROM events;    -- 传统写法
SELECT data ->> '$.type' FROM events;                -- 3.38+ 简写，返回 TEXT
SELECT data -> '$.type' FROM events;                 -- 返回 JSON（带引号的 "click"）

-- 查询 JSON 数组
SELECT * FROM events
WHERE EXISTS (
    SELECT 1 FROM json_each(json_extract(data, '$.tags'))
    WHERE value = 'ui'
);

-- 修改 JSON
SELECT json_set(data, '$.processed', true) FROM events;
SELECT json_insert(data, '$.source', 'mobile') FROM events;
SELECT json_remove(data, '$.tags') FROM events;

-- json_group_array + json_group_object：聚合为 JSON
SELECT json_group_array(json_object('name', name, 'score', score))
FROM students;
```

**JSONB（3.45+）：** 二进制 JSON 存储格式，读取更快但不可人读。适合频繁查询 JSON 字段的场景。

```sql
SELECT jsonb('{"a":1,"b":2}');  -- 返回二进制格式
```

### 2.8 生成列 Generated Columns（3.31，2020）

自动计算的列，类似 MySQL 的虚拟列：

```sql
CREATE TABLE products (
    price REAL NOT NULL,
    tax_rate REAL NOT NULL,
    total REAL GENERATED ALWAYS AS (price * (1 + tax_rate)) STORED,
    label TEXT GENERATED ALWAYS AS (
        CASE WHEN price > 100 THEN 'premium' ELSE 'standard' END
    ) VIRTUAL
);

-- STORED: 写入时计算，占磁盘空间，读取快
-- VIRTUAL: 读取时计算，不占空间（默认）
```

> 注意：生成列不能做 PRIMARY KEY，不能有 DEFAULT 值。STRICT 表的生成列必须显式声明类型。

### 2.9 UPDATE FROM（3.33，2020）

跨表更新，不再需要子查询：

```sql
-- 旧写法（子查询）
UPDATE orders SET status = (
    SELECT 'vip' FROM customers WHERE customers.id = orders.customer_id AND customers.level > 5
) WHERE customer_id IN (SELECT id FROM customers WHERE level > 5);

-- 新写法（UPDATE FROM）
UPDATE orders SET status = 'vip'
FROM customers
WHERE orders.customer_id = customers.id AND customers.level > 5;
```

### 2.10 ALTER TABLE DROP COLUMN（3.35，2021）

你 2017 年要删列只能重建整个表，现在可以直接删了：

```sql
ALTER TABLE users DROP COLUMN legacy_field;
```

底层仍然是重建表，所以大表会慢，但至少不用手写了。

同版本还加了 `ALTER TABLE RENAME COLUMN`（3.25）：

```sql
ALTER TABLE users RENAME COLUMN old_name TO new_name;
```

### 2.11 数学函数（3.35，2021）

SQLite 终于内置了数学函数，不再需要自己编译扩展：

```sql
SELECT sqrt(2);              -- 1.4142...
SELECT pow(2, 10);           -- 1024.0
SELECT ceil(3.2);            -- 4.0
SELECT floor(3.8);           -- 3.0
SELECT log(100);             -- 2.0（以 10 为底）
SELECT log2(1024);           -- 10.0
SELECT ln(2.718281828);      -- ≈1.0
SELECT pi();                 -- 3.14159...
SELECT mod(17, 5);           -- 2.0
SELECT abs(-42);             -- 42（这个一直有）
```

### 2.12 IS DISTINCT FROM（3.39，2022）

NULL 安全的不等比较：

```sql
-- 普通比较：NULL = NULL 返回 NULL（不是 true）
SELECT NULL = NULL;           -- NULL
SELECT NULL IS NULL;          -- 1

-- IS DISTINCT FROM：把 NULL 当作普通值
SELECT 1 IS DISTINCT FROM 2;      -- 1 (true)
SELECT 1 IS DISTINCT FROM NULL;   -- 1 (true)
SELECT NULL IS DISTINCT FROM NULL; -- 0 (false)

-- 实际用途：安全地比较可能为 NULL 的列
UPDATE t SET col = new_val
WHERE col IS DISTINCT FROM new_val;  -- 只在值真正变化时更新
```

---

## 三、FTS5 的演进（你关心的中文搜索）

你 2017 笔记里写了 "FTS5 没有 ICU 版本，FTS4 才有"。这个情况有变化。

### 3.1 FTS5 现状

FTS5 现在是 SQLite 推荐的全文搜索引擎，FTS4 处于维护模式。

```sql
CREATE VIRTUAL TABLE docs_fts USING fts5(title, body);
INSERT INTO docs_fts VALUES ('SQLite Guide', 'Learn advanced SQL features...');

-- 搜索
SELECT * FROM docs_fts WHERE docs_fts MATCH 'advanced SQL';

-- BM25 排名
SELECT *, rank FROM docs_fts WHERE docs_fts MATCH 'advanced' ORDER BY rank;

-- 高亮
SELECT highlight(docs_fts, 1, '<b>', '</b>') FROM docs_fts WHERE docs_fts MATCH 'SQL';

-- 片段
SELECT snippet(docs_fts, 1, '<b>', '</b>', '...', 20) FROM docs_fts WHERE docs_fts MATCH 'SQL';
```

### 3.2 中文分词

FTS5 的中文支持依然需要自定义 tokenizer。几个方案：

1. **simple tokenizer + 预分词**：在应用层用 jieba 等分词后再存入 FTS 表
2. **自定义 tokenizer**：用 C 写 FTS5 tokenizer 插件
3. **unicode61 tokenizer**：按 Unicode 类别分割，对中文勉强能用但不精确

```sql
-- unicode61 对中文按字分割（每个汉字是独立 token）
CREATE VIRTUAL TABLE chinese_fts USING fts5(content, tokenize='unicode61');
```

4. **Contentless-Delete FTS5 索引（3.43+）**：新特性，允许在 contentless FTS 表中删除记录：

```sql
CREATE VIRTUAL TABLE docs_fts USING fts5(title, body, content='', content_rowid='id');
-- 现在可以 DELETE 了，以前 contentless 表不行
```

> 你之前在 MySQL 上踩过 ngram 的坑，SQLite 的情况类似：逐字分割能搜到但召回率和精确度都有问题。
> 如果真要做中文全文搜索，建议应用层预分词 + FTS5，或者直接用 PostgreSQL/Meilisearch。

---

## 四、索引与查询优化（深入）

你 2017 年记了 EXPLAIN QUERY PLAN 的基础用法，这里深入一些。

### 4.1 EXPLAIN QUERY PLAN 实战

```sql
EXPLAIN QUERY PLAN
SELECT * FROM orders WHERE user_id = 5 AND status = 'paid';
```

输出关键词：
- `SCAN orders` → 全表扫描 ❌
- `SEARCH orders USING INDEX idx_xxx (user_id=?)` → 部分索引 ✅
- `SEARCH orders USING COVERING INDEX idx_xxx (...)` → 覆盖索引 ✅✅

### 4.2 复合索引最左前缀

```sql
CREATE INDEX idx_orders ON orders(user_id, status, created_at);

-- ✅ 能用：从最左列开始
WHERE user_id = 5
WHERE user_id = 5 AND status = 'paid'
WHERE user_id = 5 AND status = 'paid' AND created_at > '2025-01-01'

-- ❌ 不能用这个索引
WHERE status = 'paid'                   -- 跳过了 user_id
WHERE created_at > '2025-01-01'         -- 跳过了 user_id 和 status
```

### 4.3 覆盖索引

查询所需的所有列都在索引中 → 不需要回表（"Using covering index"）：

```sql
CREATE INDEX idx_covering ON orders(user_id, status, amount);

-- 这个查询完全由索引满足
SELECT status, amount FROM orders WHERE user_id = 5;
```

### 4.4 索引对函数的限制

```sql
-- ❌ 索引失效
WHERE date(created_at) = '2025-02-11'
WHERE lower(email) = 'alice@example.com'

-- ✅ 改写为范围查询
WHERE created_at >= '2025-02-11' AND created_at < '2025-02-12'

-- ✅ 或者用表达式索引
CREATE INDEX idx_lower_email ON users(lower(email));
```

### 4.5 部分索引

只对满足条件的行建索引：

```sql
CREATE INDEX idx_active ON users(email) WHERE is_active = 1;
CREATE INDEX idx_unprocessed ON jobs(created_at) WHERE status = 'pending';
```

### 4.6 实用 PRAGMA

```sql
PRAGMA table_info(users);             -- 表结构
PRAGMA table_xinfo(users);            -- 含生成列的完整信息（3.31+）
PRAGMA index_list(users);             -- 表的索引列表
PRAGMA index_info(idx_name);          -- 索引的列信息
PRAGMA foreign_key_list(orders);      -- 外键信息
PRAGMA integrity_check;               -- 数据库完整性检查
PRAGMA optimize;                      -- 让 SQLite 自动更新统计信息（定期运行）
PRAGMA analysis_limit = 1000;         -- 限制 ANALYZE 采样量（大表时有用）
```

---

## 五、事务与并发（你的多线程场景）

### 5.1 WAL 模式

你做多线程应用时，WAL 模式几乎是必选：

```sql
PRAGMA journal_mode = WAL;      -- 开启 WAL
PRAGMA busy_timeout = 5000;     -- 锁等待 5 秒
PRAGMA wal_autocheckpoint = 1000;  -- 每 1000 页自动 checkpoint
```

WAL 模式优势：
- 读写可以并发（一个写者 + 多个读者）
- 写不阻塞读，读不阻塞写
- 崩溃恢复更快

限制：
- 仍然只允许一个写者
- 不能通过网络文件系统使用（NFS/SMB）

### 5.2 事务类型

```sql
BEGIN DEFERRED;    -- 默认，第一次读时获取共享锁
BEGIN IMMEDIATE;   -- 立即获取写锁（推荐用于写操作）
BEGIN EXCLUSIVE;   -- 立即获取排他锁

-- 实际建议：写操作用 BEGIN IMMEDIATE 避免死锁
BEGIN IMMEDIATE;
INSERT INTO ...;
UPDATE ...;
COMMIT;
```

### 5.3 SAVEPOINT

```sql
BEGIN;
INSERT INTO orders VALUES (...);

SAVEPOINT before_items;
INSERT INTO order_items VALUES (...);  -- 这步可能失败
ROLLBACK TO before_items;              -- 只回滚到 savepoint

COMMIT;  -- 外层事务正常提交
```

---

## 六、View 与 CASE WHEN（你 2017 笔记中的要点补充）

### 6.1 View

你当时记的要点——删表不自动删 view、view 只读——依然正确。

补充：**TEMP VIEW** 对一次性查询很有用，连接关闭自动消失：

```sql
CREATE TEMP VIEW active_summary AS
SELECT department, COUNT(*) AS cnt
FROM employees WHERE status = 'active'
GROUP BY department;
```

### 6.2 CASE WHEN 进阶用法

CASE 的基础和 Pivot（行转列）已在入门章节 0.7 介绍。这里补充进阶用法。

**CASE + 窗口函数：**

```sql
-- 按条件分组做窗口计算
SELECT name, department, salary,
    AVG(salary) OVER (
        PARTITION BY CASE WHEN salary > 10000 THEN 'senior' ELSE 'junior' END
    ) AS tier_avg
FROM employees;
```

**FILTER 子句（3.25+，替代 CASE+聚合的更优雅写法）：**

```sql
-- 传统 CASE + 聚合（入门章节的写法）
SELECT department,
    COUNT(CASE WHEN status = 'active' THEN 1 END) AS active_count,
    SUM(CASE WHEN status = 'active' THEN salary ELSE 0 END) AS active_salary
FROM employees GROUP BY department;

-- FILTER 写法（更清晰，但目前只能配合窗口函数使用）
SELECT department,
    COUNT(*) FILTER (WHERE status = 'active') OVER (PARTITION BY department) AS active_count
FROM employees;
```

**CASE 在 UPDATE 中的用法：**

```sql
-- 批量条件更新
UPDATE products SET price = CASE
    WHEN category = 'electronics' THEN price * 0.9   -- 电子产品打九折
    WHEN category = 'books' THEN price * 0.8          -- 图书打八折
    ELSE price
END;
```

---

## 七、日期时间处理（你 2017 笔记的扩展）

你当时记了 `date('now')` 和 `strftime`。现在功能更丰富：

```sql
-- 基础（你已知道的）
SELECT date('now');                            -- 2026-02-11
SELECT datetime('now', 'localtime');           -- 本地时间
SELECT strftime('%s', 'now');                  -- Unix 时间戳

-- 日期计算
SELECT date('now', '+7 days');                 -- 7天后
SELECT date('now', '-1 month');                -- 1月前
SELECT date('now', 'start of month');          -- 本月第一天
SELECT date('now', 'start of year', '+3 months', '-1 day');  -- 第一季度最后一天

-- 两个日期之间的天数
SELECT julianday('2026-03-01') - julianday('2026-02-11');  -- 18.0

-- unixepoch() 函数（3.38+）：比 strftime('%s',...) 更方便
SELECT unixepoch();                            -- 当前 Unix 时间戳
SELECT unixepoch('2026-02-11 14:30:00');       -- 指定时间的时间戳

-- 3.46 新增：ceiling/floor 修饰符处理月份边界
SELECT date('2026-01-31', '+1 month', 'ceiling');  -- 2026-03-01
SELECT date('2026-01-31', '+1 month', 'floor');    -- 2026-02-28
```

---

## 八、生态工具

### 8.1 CLI 工具

SQLite 自带的 CLI 变化很大：

```bash
sqlite3 mydb.db

.mode box          # 3.33+ 表格输出（非常好看）
.mode json         # JSON 输出
.mode csv          # CSV 输出
.headers on        # 显示列名
.schema users      # 查看建表语句
.indexes users     # 查看索引
.expert            # 3.27+ 索引建议！根据你的查询推荐索引
.import data.csv tablename  # 导入 CSV
.output result.txt # 输出到文件
.timer on          # 显示执行时间
```

**`.expert` 命令特别实用**——你给它一条 SQL，它告诉你该建什么索引。

### 8.2 值得了解的工具

- **DB Browser for SQLite**：GUI 工具，适合快速查看和编辑
- **sqlite-utils**：Python CLI 工具，快速从 CSV/JSON 导入导出
- **Litestream**：SQLite 实时流式复制到 S3（把 SQLite 当生产数据库用的关键工具）
- **sql.js**：SQLite 编译成 WASM，在浏览器中运行
- **sqlean**：社区维护的扩展合集，补全了很多缺失函数

---

## 九、2017 笔记中的问题现在的最佳答案

| 你 2017 年的问题/做法 | 2026 年的最佳实践 |
|----------------------|------------------|
| INSERT OR IGNORE + SELECT 两步走 | `INSERT ... ON CONFLICT DO UPDATE ... RETURNING id` |
| 只支持 LEFT OUTER JOIN | 3.39 起支持 RIGHT JOIN 和 FULL OUTER JOIN |
| 自己代码里拼接字符串 | `group_concat()` / `concat_ws()`（3.44+） |
| 删列要重建整个表 | `ALTER TABLE DROP COLUMN`（3.35+） |
| 没有数学函数 | 3.35 内置 sqrt/log/pow/ceil/floor 等 |
| CASE WHEN 做条件判断 | 简单情况用 `iif()`（3.32+） |
| FTS4 + ICU 做中文搜索 | FTS5 + 应用层预分词（FTS4 已不推荐） |
| 动态类型无法约束 | `CREATE TABLE ... STRICT`（3.37+） |
| View 只读 | 依然只读，但可通过 INSTEAD OF trigger 实现可写 view |
| INSERT/UPDATE 后查 last_insert_rowid | `RETURNING` 子句直接返回（3.35+） |
| 读写混在同一个表结构里 | CQRS：规范化写表 + 触发器同步汇总表，读侧查宽表 |
| 凭感觉加索引 | `.expert` 自动推荐索引（3.27+）+ `PRAGMA optimize` |
| MySQL 的 slow_query_log | `.timer on` + 应用层埋点 + `EXPLAIN QUERY PLAN` |
| MySQL 的主从读写分离 | WAL 模式 + 应用层读写连接池分离 |

---

## 十、读写分离与 CQRS 思维

### 10.1 核心思想

CQRS（Command Query Responsibility Segregation）的本质是承认读和写有不同的需求：

| | 写（Command） | 读（Query） |
|--|--------------|------------|
| 数据结构 | 规范化（3NF），避免冗余 | 反规范化，预聚合，宽表 |
| 一致性 | 事务保证，严格校验 | 可以容忍轻微延迟 |
| 关注点 | 验证、约束、审计日志 | 速度、全文搜索、灵活聚合 |

在 MySQL 里通常通过主从复制实现物理上的读写分离。SQLite 没有主从，但 CQRS 思想依然适用——通过不同的数据结构服务不同的访问模式。

### 10.2 SQLite 中的 CQRS 实践

**方案一：写入规范化表 + 物化视图/汇总表服务读取**

```sql
-- ===== 写侧：规范化的事务表 =====
CREATE TABLE orders (
    id INTEGER PRIMARY KEY,
    customer_id INTEGER NOT NULL REFERENCES customers(id),
    product_id INTEGER NOT NULL REFERENCES products(id),
    quantity INTEGER NOT NULL,
    unit_price REAL NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    CHECK(quantity > 0),
    CHECK(unit_price > 0)
) STRICT;

-- 审计日志
CREATE TABLE audit_log (
    id INTEGER PRIMARY KEY,
    table_name TEXT NOT NULL,
    row_id INTEGER NOT NULL,
    action TEXT NOT NULL,  -- INSERT/UPDATE/DELETE
    old_data TEXT,         -- JSON
    new_data TEXT,         -- JSON
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
) STRICT;

-- 触发器自动记录审计
CREATE TRIGGER orders_audit_insert AFTER INSERT ON orders
BEGIN
    INSERT INTO audit_log(table_name, row_id, action, new_data)
    VALUES('orders', NEW.id, 'INSERT', json_object(
        'customer_id', NEW.customer_id,
        'product_id', NEW.product_id,
        'quantity', NEW.quantity
    ));
END;

CREATE TRIGGER orders_audit_update AFTER UPDATE ON orders
BEGIN
    INSERT INTO audit_log(table_name, row_id, action, old_data, new_data)
    VALUES('orders', OLD.id, 'UPDATE',
        json_object('quantity', OLD.quantity, 'unit_price', OLD.unit_price),
        json_object('quantity', NEW.quantity, 'unit_price', NEW.unit_price)
    );
END;

-- ===== 读侧：反规范化的汇总表 =====
CREATE TABLE customer_summary (
    customer_id INTEGER PRIMARY KEY,
    customer_name TEXT,
    total_orders INTEGER DEFAULT 0,
    total_spent REAL DEFAULT 0,
    last_order_at TEXT,
    top_product TEXT
);

-- 触发器同步更新汇总（写入时多做一点，读取时少做很多）
CREATE TRIGGER orders_sync_summary AFTER INSERT ON orders
BEGIN
    INSERT INTO customer_summary(customer_id, customer_name, total_orders, total_spent, last_order_at)
    SELECT NEW.customer_id, c.name, 1, NEW.quantity * NEW.unit_price, NEW.created_at
    FROM customers c WHERE c.id = NEW.customer_id
    ON CONFLICT(customer_id) DO UPDATE SET
        total_orders = total_orders + 1,
        total_spent = total_spent + NEW.quantity * NEW.unit_price,
        last_order_at = NEW.created_at;
END;
```

读侧查询变得极简：

```sql
-- 不需要 JOIN + GROUP BY，直接查汇总表
SELECT * FROM customer_summary WHERE total_spent > 10000 ORDER BY total_spent DESC;
```

**方案二：ATTACH 分库——写库和读库物理分离**

```sql
-- 写入主库（规范化）
ATTACH DATABASE 'write.db' AS write_db;

-- 读取用反规范化的宽表库
ATTACH DATABASE 'read.db' AS read_db;

-- 定期同步：从写库生成读库的宽表
INSERT OR REPLACE INTO read_db.order_details
SELECT o.id, c.name, p.name, o.quantity, o.unit_price,
       o.quantity * o.unit_price AS total,
       o.created_at
FROM write_db.orders o
JOIN write_db.customers c ON o.customer_id = c.id
JOIN write_db.products p ON o.product_id = p.id
WHERE o.created_at > ?;  -- 增量同步
```

**方案三：WAL 模式下的天然读写分离**

WAL 模式本身就提供了一定程度的读写分离——写操作不阻塞读操作：

```sql
PRAGMA journal_mode = WAL;

-- 写连接：BEGIN IMMEDIATE，保证写的原子性
-- 读连接：可以是多个并发连接，不被写阻塞
```

在应用层维护两个连接池（一个写、多个读）就是 SQLite 最简单的"读写分离"。

### 10.3 什么时候该超越 SQLite

CQRS 做到一定程度后，如果遇到这些瓶颈，说明该换工具了：

- 写并发超过 WAL 模式的单写者限制 → PostgreSQL
- 读侧需要复杂的全文搜索 + 中文分词 → Meilisearch / Elasticsearch
- 需要实时多节点同步 → PostgreSQL + 逻辑复制，或 Turso（SQLite 的分布式方案）
- 审计日志量太大影响主库性能 → 日志单独写到另一个 SQLite 文件或 ClickHouse

---

## 十一、慢查询诊断与优化

### 11.1 SQLite 的慢查询工具链

SQLite 没有 MySQL 那样的 slow query log，但有足够的工具定位问题。

**第一步：开启计时**

```bash
sqlite3 mydb.db
.timer on
-- 之后每条语句都会显示执行时间
```

在代码中：

```python
import sqlite3, time

conn = sqlite3.connect('mydb.db')
conn.set_trace_callback(lambda sql: print(f"SQL: {sql}"))

# 手动计时
start = time.perf_counter()
conn.execute("SELECT ...")
print(f"Elapsed: {time.perf_counter() - start:.3f}s")
```

**第二步：EXPLAIN QUERY PLAN — 看执行计划**

```sql
EXPLAIN QUERY PLAN
SELECT o.*, c.name
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE o.created_at > '2025-01-01'
ORDER BY o.created_at DESC
LIMIT 20;
```

你要盯住的关键词：

| 输出 | 含义 | 需要行动？ |
|------|------|-----------|
| `SCAN table` | 全表扫描 | ⚠️ 大表必须优化 |
| `SEARCH table USING INDEX` | 用了索引 | ✅ 好 |
| `SEARCH table USING COVERING INDEX` | 覆盖索引 | ✅✅ 最优 |
| `USE TEMP B-TREE FOR ORDER BY` | 排序没走索引 | ⚠️ 大结果集需要优化 |
| `USE TEMP B-TREE FOR GROUP BY` | 分组没走索引 | ⚠️ 可能需要优化 |
| `AUTOMATIC COVERING INDEX` | SQLite 临时建了索引 | ⚠️ 说明缺索引 |

**第三步：EXPLAIN（完整字节码）— 深入分析**

```sql
EXPLAIN
SELECT * FROM orders WHERE user_id = 5;
```

这会输出 SQLite 虚拟机的字节码，大多数情况 `EXPLAIN QUERY PLAN` 就够了，但遇到复杂性能问题时字节码能告诉你更多细节。

### 11.2 常见慢查询模式与解法

**模式一：缺索引导致全表扫描**

```sql
-- 慢：SCAN orders
SELECT * FROM orders WHERE customer_id = 42;

-- 加索引
CREATE INDEX idx_orders_customer ON orders(customer_id);
-- 快：SEARCH orders USING INDEX idx_orders_customer
```

**模式二：索引列上用了函数**

```sql
-- 慢：索引失效，退化为全表扫描
SELECT * FROM orders WHERE date(created_at) = '2025-02-11';

-- 快：改写为范围
SELECT * FROM orders
WHERE created_at >= '2025-02-11' AND created_at < '2025-02-12';
```

同理 `WHERE lower(email) = 'xxx'` 也会让索引失效，要么用表达式索引 `CREATE INDEX idx ON t(lower(email))`，要么在应用层统一小写后存储。

**模式三：ORDER BY 没走索引**

```sql
-- 慢：USE TEMP B-TREE FOR ORDER BY
SELECT * FROM orders WHERE status = 'paid' ORDER BY created_at DESC LIMIT 20;

-- 解法：复合索引覆盖 WHERE + ORDER BY
CREATE INDEX idx_status_created ON orders(status, created_at DESC);
```

> 注意 DESC 索引：SQLite 3.27 把 NULLS FIRST/LAST 提上了日程，但复合索引中的 DESC
> 排序从很早就支持了。如果你的查询是 `ORDER BY col DESC`，索引也要声明 DESC。

**模式四：N+1 查询（应用层问题）**

```python
# 慢：N+1 查询
customers = conn.execute("SELECT * FROM customers").fetchall()
for c in customers:
    orders = conn.execute("SELECT * FROM orders WHERE customer_id=?", (c['id'],)).fetchall()
    # ...

# 快：一条 JOIN 搞定
results = conn.execute("""
    SELECT c.*, o.id AS order_id, o.amount
    FROM customers c
    LEFT JOIN orders o ON c.id = o.customer_id
""").fetchall()
```

**模式五：大表 COUNT 慢**

```sql
-- 慢：COUNT(*) 必须扫描所有行
SELECT COUNT(*) FROM big_table WHERE status = 'active';

-- 方案 A：维护计数表（触发器同步）
CREATE TABLE counts (table_name TEXT PRIMARY KEY, active_count INTEGER);
CREATE TRIGGER update_count_insert AFTER INSERT ON big_table
WHEN NEW.status = 'active'
BEGIN
    UPDATE counts SET active_count = active_count + 1 WHERE table_name = 'big_table';
END;

-- 方案 B：如果不需要精确值
SELECT MAX(rowid) FROM big_table;  -- 近似行数，瞬间返回
```

**模式六：大 OFFSET 分页**

```sql
-- 慢：OFFSET 越大越慢，SQLite 必须跳过前 N 行
SELECT * FROM orders ORDER BY id LIMIT 20 OFFSET 100000;

-- 快：游标分页（keyset pagination）
SELECT * FROM orders WHERE id > ?last_seen_id ORDER BY id LIMIT 20;
```

### 11.3 ANALYZE 与统计信息

SQLite 的查询优化器依赖统计信息做决策。如果数据量大幅变化后查询突然变慢，可能是统计信息过时了：

```sql
-- 手动更新统计信息
ANALYZE;

-- 或者只分析特定表
ANALYZE orders;

-- 3.32+ 更智能的方式：让 SQLite 自己决定分析哪些表
PRAGMA optimize;  -- 建议在每次连接关闭前运行
```

### 11.4 .expert — 让 SQLite 推荐索引

这是 3.27 加的 CLI 功能，特别适合你不确定该建什么索引的时候：

```bash
sqlite3 mydb.db
.expert
SELECT o.*, c.name FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE o.status = 'paid' AND o.created_at > '2025-01-01';
```

它会直接告诉你：建议创建 `CREATE INDEX ... ON orders(status, created_at)` 之类的索引。

### 11.5 从 MySQL 迁移过来的经验对照

你之前在 MySQL 里处理慢查询的经验，很多思路可以直接迁移：

| MySQL 概念 | SQLite 对应 |
|-----------|-------------|
| `EXPLAIN` + `type: ALL` | `EXPLAIN QUERY PLAN` + `SCAN` |
| `EXPLAIN` + `type: ref/range` | `SEARCH ... USING INDEX` |
| `slow_query_log` | 没有内置，需要应用层埋点或 `.timer on` |
| `FORCE INDEX` / `USE INDEX` | `INDEXED BY idx_name`（SQLite 语法） |
| `OPTIMIZE TABLE` | `PRAGMA optimize` 或 `VACUUM` |
| `pt-query-digest` | 没有直接替代，需要应用层日志分析 |
| 读写分离（主从） | WAL 模式 + 应用层读写连接池 |
| `SHOW INDEX FROM table` | `PRAGMA index_list(table)` + `PRAGMA index_info(idx)` |

---

## 十二、学习路径建议

```
你现在的起点（有 2017 年的底子）
    │
    ├── 1. UPSERT + RETURNING（立竿见影，替代你旧的两步走写法）
    │
    ├── 2. 窗口函数（最大的新能力，值得花几天练）
    │
    ├── 3. STRICT 表 + 生成列（新建表时养成习惯）
    │
    ├── 4. CTE + 递归 CTE（让复杂查询变清晰）
    │
    ├── 5. 慢查询诊断（EXPLAIN + .expert + ANALYZE，立刻能解决实际问题）
    │
    ├── 6. CQRS 思维（写侧规范化 + 读侧反规范化，特别是汇总表模式）
    │
    ├── 7. JSON 函数（半结构化数据需求）
    │
    ├── 8. 索引优化深入（覆盖索引、部分索引、游标分页）
    │
    ├── 9. WAL + 事务 + 读写连接池（多线程/生产环境）
    │
    └── 10. FTS5（如果你需要搜索功能）
```

## 推荐资源

- **SQLite 官方文档**：https://sqlite.org/lang.html（质量极高，值得通读）
- **SQLite 版本变更全记录**：https://sqlite.org/changes.html
- **Modern SQL 对 SQLite 的分析**：https://modern-sql.com/blog/2019-01/sqlite-in-2018
- **SQLite 实践练习**：用你自己的真实数据，比如导入 CSV 到 SQLite 练查询
